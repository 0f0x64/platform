//automatically generated file: all used shaders as const char* strings

namespace shadersData {

const char* box = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float4 pos_size[256];\n"
"}\n"
"//]\n"
"\n"
"VS_OUTPUT_POS_UV VS(uint vID : SV_VertexID, uint iID : SV_InstanceID)\n"
"{\n"
"    VS_OUTPUT_POS_UV output;\n"
"    float2 quad[6] = { 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1 };\n"
"    float2 p = (quad[vID] - float2(0, 1)) * pos_size[iID].zw*2. + pos_size[iID].xy * float2(2, -2) - float2(1, -1);\n"
"    output.pos = float4(p, 0, 1);\n"
"    output.uv = quad [vID];\n"
"    output.uv.y = 1 - output.uv.y;\n"
"    output.sz = pos_size[iID].zw;\n"
"    return output;\n"
"}\n"
"\n"
;

const char* letter = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float width, height;\n"
"    float2 padding;\n"
"    float4 pos_size[256];\n"
"}\n"
"\n"
"cbuffer geo : register(b6)\n"
"{\n"
"    			float www;\n"
"			float hjhh;\n"
"    float4 _pos_size[256];\n"
"}\n"
"//]\n"
"\n"
"VS_OUTPUT_POS_UV VS(uint vID : SV_VertexID, uint iID : SV_InstanceID)\n"
"{\n"
"    VS_OUTPUT_POS_UV output;\n"
"    float2 quad[6] = { 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1 };\n"
"    float2 p = (quad[vID] - float2(0, 1)) * float2(width, height) + pos_size[iID].xy * float2(2, -2) - float2(1,-1);\n"
"    output.pos = float4(p, 0, 1);\n"
"    output.uv = float2(quad[vID].x, 1- quad[vID].y);\n"
"    output.uv.y /= 96.;\n"
"    output.uv.y+= pos_size[iID].z/96.;\n"
"    \n"
"    //output.sz = float2(width, height);\n"
"    return output;\n"
"}\n"
;

const char* lineDrawer = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float4 position [4000];\n"
"}\n"
"//]\n"
"\n"
"\n"
"VS_OUTPUT_POS_UV VS(uint vID : SV_VertexID)\n"
"{\n"
"    VS_OUTPUT_POS_UV output = (VS_OUTPUT_POS_UV) 0;\n"
"    output.pos.xy = position[vID].xy * float2(2, -2) + float2(-1,1);\n"
"    output.pos.z = 0;\n"
"    output.pos.w = 1;\n"
"    output.uv = 0.;\n"
"    output.uv = 1;\n"
"    \n"
"    return output;\n"
"}\n"
;

const char* lineDrawer3d = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"\n"
"//[\n"
"\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float4x4 model;\n"
"    float4 position [4000];\n"
"}\n"
"//]\n"
"\n"
"\n"
"VS_OUTPUT VS(uint vID : SV_VertexID)\n"
"{\n"
"    VS_OUTPUT output = (VS_OUTPUT) 0;\n"
"    \n"
"    float4 pos = float4(position[vID].xyz, 1);\n"
"    pos.xyz = mul(pos.xyz, (float3x3)model);\n"
"    pos.z += 12;\n"
" \n"
"    output.pos = mul(pos, proj[0]);\n"
"    output.wpos = position[vID];\n"
"    output.uv = position[vID].w;\n"
"    return output;\n"
"}\n"
;

const char* objViewer = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"Texture2D positions : register(t0);\n"
"Texture2D normals : register(t1);\n"
"SamplerState sam1 : register(s0);\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    int gX, gY;\n"
"    float4x4 model;\n"
"}\n"
"//]\n"
"\n"
"float3 rotY(float3 p, float a)\n"
"{\n"
"    float3x3 r;\n"
"    r[0] = float3(cos(a), 0, sin(a));\n"
"    r[1] = float3(0, 1, 0);\n"
"    r[2] = float3(-sin(a), 0, cos(a));\n"
"    return mul(p, r);\n"
"}\n"
"\n"
"\n"
"VS_OUTPUT VS(uint vID : SV_VertexID)\n"
"{\n"
"    VS_OUTPUT output = (VS_OUTPUT) 0;\n"
"    \n"
"    float4 grid = getGrid(vID, 1, int2(gX,gY));\n"
"    float2 uv = grid.xy;\n"
"    \n"
"    float4 pos = float4(positions.SampleLevel(sam1, uv, 0).xyz,1);\n"
"    pos = mul(pos, model);\n"
"    \n"
"    float4 normal = float4(normals.SampleLevel(sam1, uv, 0).xyz, 1);\n"
"    normal = mul(normal, transpose(model));\n"
"    //---\n"
"   // pos.xyz = rotY(pos.xyz,time.x*.1);\n"
"    //normal.xyz = rotY(normal.xyz,time.x*.1);\n"
"\n"
"\n"
"    output.vnorm = normal;\n"
"    \n"
"    output.wpos = float4(pos.xyz, 0);\n"
"    output.vpos = mul(float4(pos.xyz, 1), view[0]);\n"
"    \n"
"    output.pos = mul(pos, mul(view[0], proj[0]));\n"
"   // output.pos.x*= aspect.x;\n"
"    output.uv = grid.xy;\n"
"    return output;\n"
"}\n"
;

const char* quad = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"\n"
"VS_OUTPUT VS(uint vID : SV_VertexID)\n"
"{\n"
"    VS_OUTPUT output = (VS_OUTPUT) 0;\n"
"    float2 quad[6] = { -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1 };\n"
"    float2 p = quad[vID];\n"
"    output.pos = float4(p, 0, 1);\n"
"    output.uv = float2(1,-1)* p / 2. + .5;\n"
"    return output;\n"
"}\n"
;

const char* simpleCube = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    int  gX,gY;\n"
"}\n"
"//]\n"
"\n"
"float3 rotY(float3 p, float a)\n"
"{\n"
"    float3x3 r;\n"
"    r[0] = float3(cos(a), 0, sin(a));\n"
"    r[1] = float3(0, 1, 0);\n"
"    r[2] = float3(-sin(a), 0, cos(a));\n"
"    return mul(p, r);\n"
"}\n"
"\n"
"VS_OUTPUT VS(uint vID : SV_VertexID)\n"
"{\n"
"    VS_OUTPUT output = (VS_OUTPUT) 0;\n"
"    \n"
"    float4 grid = getGrid(vID, 1, float2(gX, gY));\n"
"    float2 uv = grid.xy-.5;\n"
"    \n"
"    float2 a = uv * PI * 2;\n"
"    float3 pos = float3(sin(a.x), sin(a.y / 2), cos(a.x));\n"
"    pos.xz *= cos(a.y / 2);\n"
"    pos = rotY(pos, 45 * PI / 180.);\n"
"    pos = clamp(pos, -.5, .5)*6;\n"
"\n"
"    //---\n"
"    output.wpos = float4(pos, 0);\n"
"\n"
"    pos = mul(pos, (float3x3) view[0]);\n"
"    output.pos = mul(float4(pos, 1), proj[0]);\n"
"    \n"
"    output.uv = grid.xy;\n"
"    return output;\n"
"}\n"
;

const char* basic = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"TextureCube env : register(t0);\n"
"Texture2D normals : register(t1);\n"
"TextureCube albedo : register(t2);\n"
"\n"
"SamplerState sam1 : register(s0);\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float hilight;\n"
"};\n"
"//]\n"
"\n"
"float3 FresnelSchlick(float3 F0, float3 v, float3 n)\n"
"{\n"
"    float cosTheta = dot(-n, v);\n"
"    return saturate(F0 + (1.0 - F0) * pow(1.0 - saturate(cosTheta), 5.0));\n"
"}\n"
"\n"
"float3 rotY(float3 pos, float a)\n"
"{\n"
"    float3x3 m =\n"
"    {\n"
"        cos(a), 0, sin(a),\n"
"        0, 1, 0,\n"
"        -sin(a), 0, cos(a)\n"
"    };\n"
"    pos = mul(pos, m);\n"
"    return pos;\n"
"}\n"
"\n"
"#define PI 3.1415926535897932384626433832795\n"
"\n"
"float4 PS(VS_OUTPUT input, bool isFrontFace : SV_IsFrontFace) : SV_Target\n"
"{\n"
"    float2 uv = input.uv;\n"
"    float3 albedo = float3(1, 1, 1);\n"
"    albedo = sin(uv.x*158)*(sin(uv.y*2));\n"
"    albedo=saturate(albedo)*float3(1,.5,.2);\n"
"\n"
"\n"
"    //return float4(albedo,1);\n"
"    float roughness = .71;\n"
"    float metalness = 0.;\n"
"    float3 F0 = .04;\n"
"    \n"
"    float3 nrml = normals.SampleLevel(sam1, input.uv,6).xyz;\n"
"    nrml += normals.SampleLevel(sam1, input.uv,0).xyz*.01;\n"
"    nrml=normalize(nrml);\n"
"    //nrml=rotY(nrml,time.x*.1);\n"
"    //nrml *= -(1 - isFrontFace * 2);\n"
"    float3 eye = input.vpos.xyz;\n"
"    eye = normalize(mul((view[0]), float4(eye, 1)));\n"
"    eye = normalize(eye);\n"
"    float3 ref = reflect(eye,nrml);\n"
"    float3 specR = env.SampleLevel(sam1, ref, roughness * 10);\n"
"    float3 diffR = env.SampleLevel(sam1, -nrml, 9.5)/3;\n"
"    \n"
"    float3 albedo_ = lerp(albedo, 0, metalness);\n"
"    F0 = lerp(F0, F0 * albedo, metalness);\n"
"    float3 F = FresnelSchlick(F0, eye, -nrml);\n"
"    F *= lerp(saturate(1 - roughness), 1, metalness);\n"
"    float3 specK = specR * F;\n"
"    float3 diffK = saturate(1.0 - F);\n"
"    diffK = albedo * diffK * diffR;\n"
"\n"
"    float3 color = diffK + specK;\n"
"    float3 screenN = mul(nrml, view[0]).xyz;\n"
"\n"
"   // color = 0; \n"
"    \n"
"    //color *= saturate(1-2 * pow(dot(normalize(mul(eye, view[0])), normalize(mul(nrml, view[0]))), .5));// * saturate(sin(eye.x * 513 + eye.y * 521 + eye.z * 432 + time.x) * 4);\n"
"    //float3 nt = mul(input.vnorm.xyz, view[0]);\n"
"    float3 nt = mul(nrml, view[0]);\n"
"    float d = dot(normalize(input.vpos.xyz), normalize(nt));\n"
"    color += saturate(10 - 35 * d)* sin(d * 127 + time.x) * 4 * hilight;\n"
"    \n"
"    color.rgb = pow(ACESFilm(color.rgb),1/2.2);\n"
"        \n"
"    return float4(color, 1);\n"
"}\n"
;

const char* box_ps = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float _aspect;\n"
"    float rad;\n"
"    float r, g, b, a;\n"
"    float soft;\n"
"    float edge;\n"
"    float outlineBrightness;\n"
"    float progress;\n"
"    float signed_progress;\n"
"    float slider_type;\n"
"}\n"
"//]\n"
"\n"
"float2 rot(float2 pos,float a)\n"
"{\n"
"    float2x2 m =\n"
"    {\n"
"        cos(a), -sin(a),\n"
"        sin(a), cos(a)\n"
"    };\n"
"    return mul(pos, m);\n"
"\n"
"}\n"
"\n"
"float roundedBoxSDF(float2 CenterPosition, float2 Size, float Radius)\n"
"{\n"
"    return length(max(abs(CenterPosition) - Size + Radius, 0.0)) - Radius;\n"
"}\n"
"\n"
"float calcRA(float2 uv, float2 sz, float radius)\n"
"{\n"
"    float2 ca = float2(1, aspect.x) ;\n"
"    float2 s = sz * ca;\n"
"    float r1 = (.001 + radius) * min(s.x, s.y);\n"
"    float r2 = roundedBoxSDF(uv*s, s*.5, r1)  / r1;\n"
"    return -r2;\n"
"\n"
"}\n"
"\n"
"float4 PS(VS_OUTPUT_POS_UV input) : SV_Target\n"
"{\n"
"    float4 color = float4(r, g, b, a);\n"
"    \n"
"    float2 uvs = (input.uv - .5);\n"
"\n"
"    float signedProgress =0;\n"
"    float Progress =0;\n"
"\n"
"    if (slider_type==1)\n"
"    {\n"
"    Progress = progress < input.uv.x ? 0. : .125;\n"
"    Progress+=progress>0 ? abs(uvs.y)*saturate(pow(saturate(1-2*abs(input.uv.x-progress)),28)) :0;\n"
"    signedProgress = saturate(pow(saturate(1-2*abs(uvs.x-progress)),8));\n"
"    signedProgress*=4*pow(abs(uvs.x),2);\n"
"    }\n"
"\n"
"    if (slider_type==2)\n"
"    {\n"
"    float iuv = 1. - input.uv.y;\n"
"    Progress = progress < iuv ? 0. : .125;\n"
"    Progress+=progress>0 ? (.4+abs(uvs.x*2))*saturate(pow(saturate(1-2*abs(iuv-progress)),28)) :0;\n"
"    signedProgress = saturate(pow(saturate(1-2*abs(uvs.y-progress)),8));\n"
"    signedProgress*=4*pow(abs(uvs.y),2);\n"
"    \n"
"    }\n"
"\n"
"    if (slider_type==3)\n"
"    {\n"
"    float2 uvsR = rot(uvs,progress.x*PI*3/2);\n"
"    float ang = saturate(1.-28*abs(uvsR.x));\n"
"    Progress = ang*saturate(sign(-uvsR.y-.2));\n"
"    Progress += saturate(1-38*abs(length(uvs)-.45));\n"
"    //Progress *= saturate(1-2.5*length(uvs))*4;\n"
"    Progress *= abs(atan2(uvs.x,uvs.y))>PI/4.2;\n"
"    signedProgress = Progress;\n"
"    \n"
"    }\n"
"  \n"
"    \n"
"    \n"
"    Progress=lerp(Progress,signedProgress,signed_progress);\n"
"   \n"
"    color += Progress;\n"
"\n"
"    float d = calcRA(uvs, input.sz, rad);\n"
"    float embossMask = sign(d) - saturate(d * edge * input.sz);\n"
"    float emboss = embossMask * dot(atan(uvs - .1), -.25);\n"
"    color.rgb += emboss;\n"
"    float2 s = input.sz;\n"
"    float m = min(s.x, s.y) / max(s.x, s.y);\n"
"    m *= length(s);\n"
"    float outline = 1 - saturate(d * 8. * sqrt(m)); // * float3(r, g, b);\n"
"    color.rgb += outline*outlineBrightness;\n"
"    return float4(color.rgb, saturate(d*soft)*color.a);\n"
"}\n"
;

const char* cubemapCreator = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float p;\n"
"}\n"
"//]\n"
"\n"
"struct PS_OUTPUT\n"
"{\n"
"    float4 c0 : SV_Target0;\n"
"    float4 c1 : SV_Target1;\n"
"    float4 c2 : SV_Target2;\n"
"    float4 c3 : SV_Target3;\n"
"    float4 c4 : SV_Target4;\n"
"    float4 c5 : SV_Target5;\n"
"    \n"
"};\n"
"\n"
"static const float3 offsetV[6] = { float3(1, 1, 1), float3(-1, 1, -1), float3(-1, 1, -1), float3(-1, -1, 1), float3(-1, 1, 1), float3(1, 1, -1) };\n"
"static const float3 offsetX[6] = { float3(0, 0, -2), float3(0, 0, 2), float3(2, 0, 0), float3(2, 0, 0), float3(2, 0, 0), float3(-2, 0, 0) };\n"
"static const float3 offsetY[6] = { float3(0, -2, 0), float3(0, -2, 0), float3(0, 0, 2), float3(0, 0, -2), float3(0, -2, 0), float3(0, -2, 0) };\n"
"\n"
"float3 ConvertUV(float2 UV, int FaceIndex)\n"
"{\n"
"    float3 outV = offsetV[FaceIndex] + offsetX[FaceIndex] * UV.x + offsetY[FaceIndex] * UV.y;\n"
"    return normalize(outV);\n"
"}\n"
"\n"
"float calcWalls(float2 uv)\n"
"{\n"
"    float walls = 0;\n"
"    float2 uv5 = float2(0, 0);\n"
"    for (int i = 0; i < 5; i++)\n"
"    {\n"
"  \n"
"        float2 xy = uv - .5 - .15 * float2(sin(i * 4. + time.x * .01), sin(i * 5. + time.x * .02));\n"
"        float2 uv4 = float2(atan2(xy.y, xy.x) * 1, 12 / (length(xy) + .1) + time.y * .1);\n"
"        walls += pow(saturate(1 - 2 * length(xy)), 62) * 120;\n"
"        uv5 += uv4;\n"
"        \n"
"    }\n"
"    walls += pow(saturate(1 - 1 * (abs(sin(uv5.x)) * abs(sin(uv5.y / 13)))), 5) * 2;\n"
"    walls = walls * saturate(1 - 2 * length(uv - .5));\n"
"    return walls;\n"
"}\n"
"\n"
"float4 env(float3 v)\n"
"{\n"
"    float a = .9*saturate(1244*sin((v.z / v.y) * 6) * sin((v.x / v.y) * 6)) ;\n"
"    float blend = saturate(8 - pow(length(v.xz / v.y), .7));\n"
"    \n"
"    float va = atan2(v.z, v.x);\n"
"    float x = frac(va / PI / 2 * 64);\n"
"    float y = frac((v.y) *10.+.5);\n"
"    \n"
"    float b = saturate(1 - 2 * length(float2(x, y) - .5));\n"
"    \n"
"    a = lerp(a, b, 1-blend);\n"
"    a = pow(a, 24)*10;\n"
"    a *= saturate(-v.y);\n"
"    a += saturate(1 - 2 * length(v.xz)) * saturate(v.y)*44;\n"
"    return float4(a, a, a, 1);\n"
"}\n"
"\n"
"PS_OUTPUT PS(VS_OUTPUT input) \n"
"{\n"
"\n"
"    float2 uv = input.uv;\n"
"    float4 color = 1;//    float4(uv, 0, 1);\n"
"\n"
"    PS_OUTPUT cube;\n"
"    \n"
"    cube.c0 = env(ConvertUV(uv, 0));\n"
"    cube.c1 = env(ConvertUV(uv, 1));\n"
"    cube.c2 = env(ConvertUV(uv, 2));\n"
"    cube.c3 = env(ConvertUV(uv, 3));\n"
"    cube.c4 = env(ConvertUV(uv, 4));\n"
"    cube.c5 = env(ConvertUV(uv, 5));\n"
"\n"
"    return cube;\n"
"}\n"
;

const char* cubeMapViewer = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/utils.shader>\n"
"\n"
"TextureCube env : register(t0);\n"
"SamplerState sam1 : register(s0);\n"
"\n"
"float4 PS(VS_OUTPUT input) : SV_Target\n"
"{\n"
"    float4 color = env.SampleLevel(sam1, float4(normalize(input.wpos.xyz),0), 0);\n"
"    \n"
"    color.rgb = pow(ACESFilm(color.rgb ), 1 / 2.2);\n"
"    return color;\n"
"}\n"
;

const char* genNormals = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"#include <../lib/constants.shader>\n"
"\n"
"Texture2D geo : register(t0);\n"
"SamplerState sam1 : register(s0);\n"
"\n"
"float4 PS(VS_OUTPUT input) : SV_Target\n"
"{\n"
"    uint sgX, sgY;\n"
"    geo.GetDimensions(sgX, sgY);\n"
"\n"
"    float a = 1;\n"
"    sgY *= a;\n"
"    sgX *= a;\n"
"    float2 uv = input.uv;\n"
"\n"
"    float4 pt0 = geo.Sample(sam1, uv + float2(-1. / sgX, 0));\n"
"    float4 pt1 = geo.Sample(sam1, uv + float2(1. / sgX, 0));\n"
"    float4 pt2 = geo.Sample(sam1, uv + float2(0, -1. / sgY));\n"
"    float4 pt3 = geo.Sample(sam1, uv + float2(0, 1. / sgY));\n"
"    float3 n = normalize(cross(pt0.xyz - pt1.xyz, pt2.xyz - pt3.xyz));\n"
"    \n"
"    float3 color = n;\n"
"    return float4(color, 1);\n"
"\n"
"}\n"
;

const char* letter_ps = 
"#include <../lib/constBuf.shader>\n"
"#include <../lib/io.shader>\n"
"\n"
"Texture2D tex : register(t0);\n"
"SamplerState s1 : register(s0);\n"
"\n"
"//[\n"
"cbuffer params : register(b0)\n"
"{\n"
"    float r, g, b, a;\n"
"    float bold;\n"
"}\n"
"//]\n"
"\n"
"\n"
"float4 PS(VS_OUTPUT_POS_UV input) : SV_Target\n"
"{\n"
"    float4 color = tex.SampleLevel(s1, input.uv, 0);\n"
"    color.a = saturate(dot(color.rgb, 1));\n"
"    color *= float4(r, g, b, a);\n"
"    return float4(color);\n"
"}\n"
